/********************************************************************************
* Copyright 2017-2022 Secure Thingz Ltd.
* All rights reserved.
*
* This source file and its use is subject to a Secure Thingz Embedded Trust
* License agreement. This source file may contain licensed source code from
* other third-parties and is subject to those license agreements as well.
*
* Permission to use, copy, modify, compile and distribute compiled binary of the
* source code for use as specified in the Embedded Trust license agreement is
* hereby granted provided that the this copyright notice and other third-party
* copyright notices appear in all copies of the source code.
*
* Distribution of Embedded Trust source code in any form is governed by the
* Embedded Trust license agreement. Use of the Secure Thingz name or trademark
* in any form is prohibited.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
* ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
* LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
* INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
* CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
* ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
* POSSIBILITY OF SUCH DAMAGE.
*******************************************************************************/

/**
 * \file
 * \brief This file defines the specific types for the device in question.
 *
 * Note: The enums, field names and structure layout must not be changed
 * as the SM will autogenerate the tables and macros.
 */

#ifndef MEMORY_DEVICES_AND_SLOTS_H
#define MEMORY_DEVICES_AND_SLOTS_H

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

/** Types of unique IDs used by device and slot descriptors. */
typedef uint32_t memory_device_id_t;
typedef uint32_t memory_slot_id_t;

/**
 * Reserved unique IDs.
 * Note: these macros must not start with "DEVICE_ID" and "SLOT_ID",
 * as those prefixes are reserved for actual IDs placed
 * in autogenerated_memory_devices_and_slots.h.
 */
#define MEMORY_DEVICE_ID_INVALID ((memory_device_id_t)-1)
#define MEMORY_SLOT_ID_INVALID ((memory_slot_id_t)-1)

/**
 * Types of drivers supported by the SBM (actual device-specific drivers
 * depend on level of support STz will provide).
 *
 * Note: this order of values in this enum matters; as the type of the driver
 * is used as one of the creteria to resolve the priority of update slots, the
 * lower the value is when cast to int, the higher is the priority of update
 * slot is.
 */
typedef enum
{
    SOC_RAM_DRV,
    SOC_FLASH_DRV,
    EXT_MEM_MAPPED_DRV,
    EXT_FLASH_DRV,

    MEMORY_DRV_MAX
} memory_drv_t;

/** Type that describes a memory subregion with uniform access/properties. */
typedef struct
{
    uintptr_t  start_address;
    uintptr_t  end_address;
    uint32_t   page_size;
    uint32_t   min_write_size;
    uint8_t    erase_value;
} memory_subregion;

/** Type that describes a single memory device. */
typedef struct
{
    memory_device_id_t  id;
    const char         *name;
    memory_drv_t        memory_drv;
    size_t              first_subregion_idx;
    size_t              last_subregion_idx;
    bool                removable;
} memory_device;

/** Slot types */
typedef enum
{
    UPDATE_SLOT_TYPE,
    EXEC_SLOT_TYPE,
    SBM_SLOT_TYPE,
    ASS_SLOT_TYPE,
    SFI_SLOT_TYPE,

    MEMORY_SLOT_TYPE_MAX
} memory_slot_type_t;

/** Type that describes a single slot */
typedef struct
{
    memory_slot_id_t    id;
    const char         *name;
    memory_slot_type_t  slot_type;
    size_t              memory_device_idx;
    uintptr_t           start_address;
    size_t              size;
    bool                prevent_erase;
} memory_slot;

/** Device specific memory devices and slots. */
#ifndef NO_INCLUDE_AUTOGENERATED_MEMORY_DEVICES_AND_SLOTS
#include "autogenerated_memory_devices_and_slots.h"
#endif /* NO_INCLUDE_AUTOGENERATED_MEMORY_DEVICES_AND_SLOTS */

/* Device-specific memory slots */

/**
 * Override qualifiers for memory devices and slots storage and internal
 * states. Normally, the memory devices and slots tables should be read-only,
 * however, certain tests may wish to overwrite the qualifiers to allow
 * modification at run-time. DO NOT set this macro, unless required by
 * specific tests.
 */
#ifdef OVERRIDE_DEVICES_AND_SLOTS_QUALIFIERS /* Used for unit testing */
#define MDAS_CONST
#define MDAS_STATIC_CONST
#else
#define MDAS_CONST const
#define MDAS_STATIC_CONST static const
#endif /* ifdef OVERRIDE_DEVICES_AND_SLOTS_QUALIFIERS */

extern MDAS_CONST memory_slot sbm_slot;
extern MDAS_CONST memory_slot app_status_slot;
extern MDAS_CONST memory_slot exec_slot;

#if NUM_UPDATE_SLOTS > 0
extern MDAS_CONST memory_slot update_slots[];
#endif /* NUM_UPDATE_SLOTS > 0 */

/**
 * Get the address of the memory device based on memory slot.
 *
 * \param slot Address of the memory slot.
 * \return Address of the memory device table entry
 */
const memory_device *get_device_from_slot(const memory_slot *slot);

/**
 * Return a pointer to the update memory slot table entry based on memory slot ID.
 *
 * \param id Update slot ID (must be different than #MEMORY_SLOT_ID_INVALID)
 * \return Pointer to the update memory slot table entry or NULL if not found
 */
const memory_slot *get_update_slot_from_id(memory_slot_id_t id);

/**
 * Get the address of the memory subregion in which a given address/offset resides.
 *
 * \param device Pointer to the memory device table entry
 * \param address Address/offset within the specified device's memory space
 * \return Pointer to the memory subregion table entry or NULL if no match was found
 */
const memory_subregion *get_subregion_from_address(const memory_device *device, const uintptr_t address);

/**
 * Check that the specified address range is a valid contiguous range within the device's address space.
 *
 * The address range may span across multiple memory subregions, provided those subregions
 * are contiguous.
 *
 * \param device The memory device to query against.
 * \param address The address of the first byte in the range to verify.
 * \param size The length of the address range, in bytes.
 * \retval \c true if the specified address range is valid for the specified memory device
 * \retval \c false if at least part of the specified address range is not valid for the specified memory device.
 */
bool is_address_range_within_memory_device_bounds(const memory_device *device, const uintptr_t address, const size_t size);

/**
 * Check that the specified address range is a valid contiguous range within the device's address space.
 *
 * The address range may span across multiple memory subregions, provided those subregions
 * are contiguous.
 *
 * \param device The memory device to query against.
 * \param address The address of the first byte in the range to verify.
 * \param size The length of the address range, in bytes.
 * \retval \c true if the specified address range is valid for the specified memory device
 * \retval \c false if at least part of the specified address range is not valid for the specified memory device.
 */
bool is_address_range_within_memory_device_bounds(const memory_device *device, const uintptr_t address, const size_t size);

#endif /* MEMORY_DEVICES_AND_SLOTS_H */
